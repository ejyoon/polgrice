// webppl politeness.wppl --require utils

// a world has both a state and a valence
// var worlds = [
// 	{state: "terrible", valence: 1},
// 	{state: "bad", valence: 2},
// 	{state: "okay", valence: 3},
// 	{state: "good", valence: 4},
// 	{state: "amazing", valence: 5}
// ]

// var states = [0,1,2,3,4]
var states = [1,2,3,4,5]
var utterances = ["terrible","bad","okay","good","amazing"]
// array of the valence values
// var worldValues = _.pluck(worlds, "valence")
// var meanWorldValues = _.pluck(worlds, "valence").reverse()

var statePrior = function(){
	return uniformDraw(states)
}

// array of the state values (also the utterances)
// var stateValues = _.pluck(worlds, "state")

var utterancePrior = function(){
	return uniformDraw(utterances)
}

// var politeRSA = function(experimentalCondition, opts, RSAparams, priorParams, semantics, queryStatement){
var politeRSA = function(experimentalCondition, RSAparams, priorParams, weights, semantics, queryStatement){

	var speakerOptimality = RSAparams.speakerOptimality
	var alpha = RSAparams.alpha
	// var weightScale = RSAparams.weightScale
	// var weightScale = priorParams.weightScale
	var weightBins = [0.01,0.1,0.3,0.5,0.7,0.9,0.99]
	var doubleWeightsBins = [-0.99,-0.9,-0.7,-0.5,-0.3,-0.1,0.1,0.3,0.5,0.7,0.9,0.99]
	var doubleWeightsProxyBins = [0.01,0.1,0.2,0.3,0.4,0.45,0.55,0.6,0.7,0.8,0.9,0.99] // artificially making a Beta scale to (-1,1)
 	var goalPriors = priorParams.includeMeanness == "oneScale" ? 
 	{
 		honesty: discretizeBeta(priorParams.honestGamma, priorParams.honestDelta, weightBins),
 		kindness: discretizeBeta(priorParams.kindGamma, priorParams.kindDelta, doubleWeightsProxyBins),
 		meanness : false
  	} : 
  	priorParams.includeMeanness ? 
 	{
 		honesty: discretizeBeta(priorParams.honestGamma, priorParams.honestDelta, weightBins),
 		kindness: discretizeBeta(priorParams.kindGamma, priorParams.kindDelta, weightBins),
 		meanness: discretizeBeta(priorParams.meanGamma, priorParams.meanDelta, weightBins)
 	} : 
 	{
 		honesty: discretizeBeta(priorParams.honestGamma, priorParams.honestDelta, weightBins),
 		kindness: discretizeBeta(priorParams.kindGamma, priorParams.kindDelta, weightBins),
 		meanness: false
 	}
	// var honestyWeights = discretizeBeta(priorParams.honestGamma, 
	// 									priorParams.honestDelta, 
	// 									[0.1,0.3,0.5,0.7,0.9]
	// 									// [0.05,0.2,0.4,0.6,0.8,0.95]
	// 									)
	// var kindnessWeights = discretizeBeta(priorParams.kindGamma, 
	// 									priorParams.kindDelta, 
	// 									[0.1,0.3,0.5,0.7,0.9]
	// 									// [0.05,0.2,0.4,0.6,0.8,0.95]
	// 									)
	// var meannessWeights = discretizeBeta(priorParams.meanGamma, 
	// 									priorParams.meanDelta, 
	// 									[0.1,0.3,0.5,0.7,0.9]
	// 									// [0.05,0.2,0.4,0.6,0.8,0.95]
	// 									)


	// var weightBins = [0.1, 1, 5, 10, 20]

	// var honestyWeights = gaussianPMF(priorParams.honestMu, 
	// 									priorParams.honestSigma, 
	// 									weightBins
	// 									)
	// var kindnessWeights = gaussianPMF(priorParams.kindMu, 
	// 									priorParams.kindSigma, 
	// 									weightBins
	// 									)
	// var meannessWeights = gaussianPMF(priorParams.meanMu, 
	// 									priorParams.meanSigma, 
	// 									weightBins
	// 									)

	// var kindnessWeights = discretizeBeta(priorParams.kindGamma, 
	// 									priorParams.kindDelta, 
	// 									[0.05,0.15,0.25,0.35,0.45,
	// 									 0.55,0.65,0.75,0.85,0.95])

	// var meannessWeights = discretizeBeta(priorParams.meanGamma, priorParams.meanDelta)
	// var honestyWeights = [1,1,1,1,1]
	// var kindnessWeights = [1,1,1,1,1]
	// var kindnessWeights = [1,1,1,1,1]
	// var kindnessWeights = [1,1,1,1,1,1,1,1,1,1]

	// var literalSemantics = {
	// 	"terrible":[.95,.30,.02,.02,.02],
	// 	"bad":[.85,.85,.02,.02,.02],
	// 	"okay":[0.01,0.25,1,.65,.35],
	// 	"good":[.02,.05,.55,.95,.93],
	// 	"amazing":[.02,.02,.02,.65,1]
	// }

	var meaning = function(words, state){
		// console.log(words + " " + state + " " + semantics[[words,state+1].join()])
	    return words=="mu" ? true : flip(semantics[[words,state].join()])
	}


	var listener0 = cache(function(utterance) {
	  Enumerate(function(){
		var state = statePrior()
		var m = meaning(utterance, state)
		condition(m)
		return state
	  })
	},10000)


	var speaker1 = cache(function(state, speakerGoals, speakerOptimality) {
	  Enumerate(function(){
	  	// console.log("state = " + state)
	  	// console.log(speakerGoals)
	    var utterance = utterancePrior()

	    var L0 = listener0(utterance)
	    // console.log(map(function(s){return [s, Math.exp(L0.score([], s))]}, states))

	    var epistemicUtility = L0.score(state)

	    var socialUtility = expectation(L0, function(s){return alpha*s})
	    // display(alpha)
	    // display("sutility" + socialUtility)

	    var eUtility = speakerGoals.honesty*epistemicUtility 
	    var sUtility = speakerGoals.kindness*socialUtility
	    var mUtility = priorParams.includeMeanness == "oneScale" ? 0 :
	    				priorParams.includeMeanness ? speakerGoals.meanness*socialUtility : 0

	    // display(eUtility)
	    // display(sUtility)
	    // display(mUtility)
	    factor(speakerOptimality*(eUtility+sUtility-mUtility))
	    // factor(eUtility+sUtility)

	    return utterance

	  })
	},10000)

	var listener1 = function(exptCondition, goalPriors, weights, queryStatement) {
	  Enumerate(function(){

	  	// console.log(exptCondition)
	  	// console.log(goalPriors)
	  	// console.log(weights)
	  	// console.log(queryStatement)

	  	var utterance = exptCondition.utterance
	  	var trueState = exptCondition.state
	  	var knownGoals = exptCondition.goal

	    var honestyPrior = goalPriors.honesty
	    var kindnessPrior = goalPriors.kindness
	    var meannessPrior = goalPriors.meanness

	    var state = statePrior()

	    var speakerGoals = weights ? weights : 
		    priorParams.includeMeanness == "oneScale" ?
		    {
		      honesty: weightBins[discrete(honestyPrior)],
		      kindness: doubleWeightsBins[discrete(kindnessPrior)]
		     } :
		    priorParams.includeMeanness ?
		    {
		      honesty: weightBins[discrete(honestyPrior)],
		      kindness: weightBins[discrete(kindnessPrior)],
		      meanness : weightBins[discrete(meannessPrior)]
		     } : 
		    {
		      honesty: weightBins[discrete(honestyPrior)],
		      kindness: weightBins[discrete(kindnessPrior)]
		     } 

	    condition(trueState ? trueState == state : true)

	    // foreach(_.keys(weights), function(g){
		   //  condition(speakerGoals[g] == weights[g])
	    // })

	    var S1 = speaker1(state, speakerGoals, speakerOptimality)


	    factor(S1.score(utterance))

	    // var returnGoals = {honesty: speakerGoals.honesty,
	    //       kindness: speakerGoals.kindness > 0 ? speakerGoals.kindness : 0,
	    //       meanness: speakerGoals.kindness > 0 ? 0 : -speakerGoals.kindness}

	    var returnStatement = {
	      state: 20*state,
	      goals: speakerGoals
	    }

	    return returnStatement[queryStatement]
	  })
	}


	return listener1(experimentalCondition, goalPriors, weights, queryStatement)
}