// time webppl BDA_politeRSA.wppl --require mht --require utils
// time ~/webppl-infer/webppl BDA_politeRSA.wppl --require mht --require utils
var fpath = "/Users/mht/Documents/research/polgrice/experiment/data_analysis/data/"

var rawData = utils.readCSV(fpath+"goal_unknown_rounded.csv").data
var df = dataFrame(rawData.slice(0, rawData.length-1), ["roundval"])

var allKnowledges = _.uniq(_.pluck(df,"knowledge"))
var allUtterances = _.uniq(_.pluck(df,"utterance"))
var allStates = _.uniq(_.pluck(df,"true_state"))
var allGoals = ["nice","honest","mean"] // _.uniq(_.pluck(df,"goal"))

var goalDictionary = {
	"nice": "kindness",
	"honest" : "honesty",
	"mean" : "meanness"
}

var stateDictionary = {
	"terrible":1,
	"bad":2,
	"okay":3,
	"good":4,
	"amazing":5
}
// run BDA on literal semantics data
var sem_mhiter = 50000
var sem_burn = sem_mhiter/2
var incrOpts = {samples: sem_mhiter, burn:sem_burn, verbose: true, verboseLag: sem_mhiter/10}
// semanticsBDA()
var semanticsERP = IncrementalMH(semanticsBDA, incrOpts)


var logistic = function(x0, midpoint,k){
  return 1 / (1 + Math.exp(-k*(midpoint - x0)))
}
var roundToBin = function(x){
  var roundFive = x < 0.2 ? 0.1 :
                  x < 0.4 ? 0.3 :
                  x < 0.6 ? 0.5 :
                  x < 0.8 ? 0.7 :
                  0.9
  return roundFive
}


var addGuessing = function(erp, phi){
    Enumerate(function(){
        var x = flip(1-phi) ? 
                    sample(erp) :
                    uniformDraw([0.1,0.3,0.5,0.7,0.9])
        return x
    })
}

// var semanticsERPobject = _.object(
// 	map(function(s){
// 		return [s, _.object(map(function(u){
// 			return [u, marginalize(semanticsERP, [u,s])]
// 		}, allUtterances))]
// },allStates))

// sample(semanticsERP)





var weights = false

var dataAnalysis = function(){

	var RSAparams = {
		speakerOptimality : sample(UniformDrift({a: 0, b: 20, r: 1.0})),
		alpha: sample(UniformDrift({a: 0, b: 10, r: 0.5}))
	}

	var semantics = sample(semanticsERP)

	foreach(allStates, function(state){

		var stateData = subset(df, "true_state", state)

		foreach(allUtterances, function(utterance){

			var utteranceData = subset(stateData, "utterance", utterance)

			var predictiveERP = politeRSA({utterance: utterance, state: stateDictionary[state]},
				RSAparams, weights, semantics, "goals")

			foreach(allGoals, function(goal){

				var dataPoints = _.pluck(subset(utteranceData, "goal", goal), "roundval")
				var goalERP = marginalize(predictiveERP, goalDictionary[goal])
				// console.log(dataPoints)
				var likelihoodOfData = sum(map(function(d){return goalERP.score(d)}, dataPoints))

				factor(likelihoodOfData)

				query.add(["predictive" ,stateDictionary[state], utterance, goal], expectation(goalERP))

			})
		})
	})

	query.add(["parameter","speakerOptimality", "NA", "NA"], RSAparams.speakerOptimality)
	query.add(["parameter","alpha", "NA", "NA"], RSAparams.alpha)
	return query
}


var inference ='MH'
var samples = 10000
var burn =  samples/2
var resultsERP = MCMC(dataAnalysis, {samples:samples/2, burn:burn, verbose:true})
// var resultsERP = MCMC(dataAnalysis, 
	// {samples:samples/2, burn:burn, verbose:true,
		// kernel: {HMC: {steps: 5, stepSize:0.01}}})

console.log('inference complete... printing')

// var outfile = "results/bda-politeRSA-truesopt-alpha"+ 
// 						inference + samples + "burn" + burn + 
// 						"semantics-bern-" + sem_mhiter/1000 + "k-b" + sem_burn/1000 +"ka.csv"

var outfile = "results/bda-politeRSA-truesopt-alpha"+ 
						inference + samples + "burn" + burn + 
						"semantics-bern-" + sem_mhiter/1000 + "k-b" + sem_burn/1000 +"kc.csv"

utils.erpWriter(resultsERP, outfile)

console.log('output written to ' + outfile)